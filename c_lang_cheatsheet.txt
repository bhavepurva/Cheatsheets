->The main features of the C language include low-level memory access, a simple set of keywords, and a clean style.C++ is nearly a superset of C language (Few programs may compile in C, but not in C++).

-> Structure of c program:

~header			#include <stdio.h>   //header file have extension .h
*all lines that start with # are processed by preprocessor which is a program invoked by compiler, In a very basic term, preprocessor takes a C program and produces another C program without any #.*
some of C header files: 
stddef.h – Defines several useful types and macros.
stdint.h – Defines exact width integer types.
stdio.h – Defines core input and output functions
stdlib.h – Defines numeric conversion functions, pseudo-random network generator, memory allocation
string.h – Defines string handling functions
math.h – Defines common mathematical functions

~main()	
		
~variable declaration
It refers to the variables that are to be used in the function. The variables are to be declared before any operation in the function.

~body
The body of a function in the C program, refers to the operations that are performed in the functions.

~return
 This return statement and return value depend upon the return type of the function.

->According to MinGW(MinGW is a compiler system based on the GNU GCC and Binutils projects that compiles and links code to be run on Win32 (Windows) systems) the size of one ‘int’ is 4 bytes.
~signed int - An ‘int’ type variable in C language is able to store only numbers till 2147483647. An ‘int’ is actually 1 sign bit + 31 data bits.The sign is also represented by binary digits, 0 for positive sign and 1 for negative sign. 

~unsigned int - only positive numbers can be stored. In this data type, all the 32 bits will be reserved for the storage of data.  Therefore, the maximum value that can be stored is 4294967295. The format specifier for unsigned integer is “%u”.

->Even if your compiler accepts “void main()” avoid it, or risk being considered ignorant by C and C++ programmers. 
In C++, main() need not contain an explicit return statement. In that case, the value returned is 0, meaning successful execution. using “int main(void)” is a recommended practice in C.

->The following are some interesting facts about preprocessors in C. 
~When we use include directive,  the contents of included header file (after preprocessing) are copied to the current file. 
~Angular brackets < and > instruct the preprocessor to look in the standard folder where all header files are held. 
~Double quotes “ and “ instruct the preprocessor to look into the current folder (current directory). 
~ When we use define for a constant, the preprocessor produces a C program where the defined constant is searched and matching tokens are replaced with the given expression.


->macros - The macros can take function like arguments, the arguments are not checked for data type. 
#include <stdio.h>
#define change(x) x+=2 #kind of like lambda functions
int main()
{
    int x=10;
    char *y="abc";
    printf("%d",change(x));  //12
    printf("%s",change(y));  //c
}

->The macro arguments are not evaluated before macro expansion.
#include <stdio.h>
#define MULTIPLY(a, b) a*b
int main()
{
    // The macro is expanded as 2 + 3 * 3 + 5, not as 5*8
    printf("%d", MULTIPLY(2+3, 3+5));
    return 0;
}

to solve this problem we write
#include <stdio.h>
//here, instead of writing a*a we write (a)*(b)
#define MULTIPLY(a, b) (a)*(b)
int main()
{
    // The macro is expanded as (2 + 3) * (3 + 5), as 5*8
    printf("%d", MULTIPLY(2+3, 3+5));
    return 0;
}

->The tokens passed to macros can be concatenated using operator ## called Token-Pasting operator.
#include <stdio.h>
#define merge(a, b) a##b
int main()
{
    printf("%d ", merge(12, 34));   //variables didn't work
}

->A token passed to macro can be converted to a string literal by using # before it.
#include <stdio.h>
#define get(a) #a
int main()
{
    // GeeksQuiz is changed to "GeeksQuiz"
    printf("%s", get(GeeksQuiz));
}

->inline functions
#include <stdio.h>
 
static inline int square(int x) { return x*x; }
int main()
{
int x = 36/square(6);
printf("%d", x);
return 0;
}

->Preprocessors also support if-else directives which are typically used for conditional compilation. 
int main()
{
#if VERBOSE >= 2
  printf("Trace Message");
#endif
}

->A header file may be included more than one time directly or indirectly, this leads to problems of redeclaration of same variables/functions. To avoid this problem, directives like defined, ifdef and ifndef are used. 

->There are some standard macros which can be used to print program file (__FILE__), Date of compilation (__DATE__), Time of compilation (__TIME__) and Line Number in C code (__LINE__)
#include <stdio.h>
int main()
{
   printf("Current File :%s\n", __FILE__ );
   printf("Current Date :%s\n", __DATE__ );
   printf("Current Time :%s\n", __TIME__ );
   printf("Line Number :%d\n", __LINE__ );
   return 0;
}

->We can remove already defined macros using : 
#undef MACRO_NAME 

->C is a mid-level language and it needs a compiler to convert it into an executable code so that the program can be run on our machine. 
How do we compile and run a C program?
->ubuntu
~save file as file_name.c
~compile-> $ gcc -Wall file_name.c -o file_name   //-Wall enables warnings, -o to define output filename, if not defined output file with "a.out" is created
~run the executable-> $ ./file_name

What goes inside the compilation process?
Compiler converts a C program into an executable. There are four phases for a C program to become an executable: 

-Pre-processing
Removal of Comments
Expansion of Macros -printf contains now a + b rather than add(a, b) that’s because macros have expanded.
Expansion of the included files. - #include<stdio.h> is missing instead we see lots of code.
Conditional compilation
The preprocessed output is stored in the filename.i.

-Compilation
The next step is to compile filename.i and produce an; intermediate compiled output file filename.s. This file is in assembly level instructions.

-Assembly
In this phase the filename.s is taken as input and turned into filename.o by assembler. This file contain machine level instructions. 

-Linking
This is the final phase in which all the linking of function calls with their definitions are done. Linker knows where all these functions are implemented. Linker does some extra work also, it adds some extra code to our program which is required when the program starts and ends.

->benefits 0f c
-As a middle-level language, C combines the features of both high-level and low-level languages. It can be used for low-level programming, such as scripting for drivers and kernels and it also supports functions of high-level programming languages, such as scripting for software applications etc.
-C is a structured programming language which allows a complex program to be broken into simpler programs called functions.
-Various features of C including direct access to machine level hardware APIs, the presence of C compilers, deterministic resource use and dynamic memory allocation make C language an optimum choice for scripting applications and drivers of embedded systems.
-C language is case-sensitive which means lowercase and uppercase letters are treated differently.
-C is highly portable and is used for scripting system applications which form a major part of Windows, UNIX, and Linux operating system.
-C is a general-purpose programming language(They include procedural, functional and object-oriented programming languages, including scripting and/or dynamically typed languages. Examples of general-purpose programming languages include C#, C++, Java, JavaScript, Python, Ruby and Visual Basic.
) and can efficiently work on enterprise applications, games, graphics, and applications requiring calculations, etc.
-C language has a rich library which provides a number of built-in functions. It also offers dynamic memory allocation.
-C implements algorithms and data structures swiftly, facilitating faster computations in programs. This has enabled the use of C in applications requiring higher degrees of calculations like MATLAB and Mathematica.

*The C language has formed the basis for many languages including C++, C–, C#, Objective-C, BitC, C-shell, csh, D, Java, JavaScript, Go, Rust, Julia, Limbo, LPC, PHP, Python, Perl, Seed7, Vala, Verilog and many more other languages are there.

->Signals in computers are a way of communication between the process and the OS.Signal and interrupt are basically same but a small distinction exists i.e interrupts are generated by the processor and handled by the kernel but signals are generated by the kernel and handled by the process. Error signals generally causes termination of the program and a core dump file is created named core, which stores the state of the process at the moment of termination. This file can be investigated using debugger to know the cause of program termination.
->error signals:
-SIGFPE –
This error signal denotes some arithmetic error that occurred like division by zero, floating point error.
-SIGILL –
This signal denotes illegal instruction. When a garbage instruction or instruction which a program has no privilege to execute, is executed then this signal is generated.This signal is also generated when stack overflow occurs.
-SIGSEGV –
The signal is generated when process tries to access memory location not allocated to it, like de-referencing a wild pointer which leads to “segmentation fault”.
-SIGBUS –
The name is an abbreviation for “Bus error”. This signal is also produced when an invalid memory is accessed. 
-SIGABRT –
If an error itself is detected by the program then this signal is generated using call to abort().assert() function in c++ also uses abort() to generate this signal.
-SIGSYS –
This signal is sent to process when an invalid argument is passed to a system call.
-SIGTRAP –
This signal is send to process when an exception is occurred.

In C programming language, there are 256 numbers of characters in character set. The entire character set is divided into 2 parts i.e. the ASCII characters set and the extended ASCII characters set.ESCAPE characters are not the part of any characters set.
\a,\b,\n,\t,\v,\r,\\,\

->Lines terminated by a \ are spliced together with the next line very early in the process of translation.Actually whenever at the end of the comment line if we use \(backslash) character then it merges the immediate next line with current line which makes the new line also as a comment for the compiler. To avoid this issue multi-line comment can be used.Represented as /* any_text */ start with forward slash and asterisk (/*) and end with asterisk and forward slash (*/). It is used to denote multi-line comment.

->A token is the smallest element of a program that is meaningful to the compiler. Tokens can be classified as follows:  
Keywords
Identifiers
Constants(also called literals) - const data_type variable_name
Strings - Strings are nothing but an array of characters ended with a null character (‘\0’), **strings in double quotes and char in single quotes.**.when we declare char as “string[20]”, 20 bytes of memory space is allocated for holding the string value.
When we declare char as “string[]”, memory space will be allocated as per the requirement during the execution of the program.
Special Symbols
Operators
**C language supports 32 keywords,While in C++ there are 31 additional keywords other than C Keywords

-> operators
unary= increment,decrement
binary= arithmetic,relational,logical,assignment,conditional,bitwise

->variables 
Variable declaration refers to the part where a variable is first declared or introduced before its first use. Variable definition is the part where the variable is assigned a memory location and a value.



